
<header>
    <nav>
      <ul>
        <li><a href="lab1.html">lab1 - wyświetlanie </a></li>
        <li><a href="lab2.html">lab2 - wyświetlanie w 16-tkowym</a></li>
        <li><a href="lab3.html">lab3 - sortowanie tablicy int</a></li>
        <li><a href="lab4.html">lab4 - brak </a></li>
        <li><a href="lab5.html">lab5 - zamiana liter małych na duże i odwrotnie </a></li>

        <li><a href="lab6a.html">lab6a - silnia </a></li>
		<li><a href="lab6b.html">lab6b - fibonaci </a></li>

		<li><a href="lab7a.html">lab7a - silnia nie rekurencyjnie </a></li>
		<li><a href="lab7b.html">lab7b - fib nie rekurencyjnie </a></li>
		<li><a href="lab7d.html">lab7d - budowanie stringa </a></li>

        <li><a href="lab8a.html">lab8a - wyświetlanie zmiennych środowiskowych</a></li>


        <li><a href="lab9a.html">lab9a - operacje na zmiennoprzecinkowych </a></li>
        <li><a href="lab9b.html">lab9b - pierwiastki równania kwadratowego </a></li>

        <li><a href="jk1.html">jk1 - maksymalna różnica max_diff(ina, int b, int c, int d) </a></li>
        <li><a href="jk2.html">jk2 - generuj string generate_str(char* s, int c, int n, int inc) </a></li>
        <li><a href="jk3.html">jk3 - łączenie stringów w jeden char* fun(char* buf, char* a, char* b)</a></li>
        <li><a href="jk4.html">jk4 - max index max_ind(int a, int b, int c, int d)</a></li>
		<li><a href="jk5.html">jk5 - (poprawkowy) dziwny max na longach max_1_ind(long long *tab, long long n, long long *even_count, long long *neg_count)</a></li>




        <li><a href="pw1.html">pw1 - maksymalna różnica max_diff(ina, int b, int c, int d) </a></li>
        <li><a href="ds2.html">ds2 - generuj string generate_str(char* s, int c, int n, int inc) </a></li>
        <li><a href="ds3.html">ds3 - łączenie stringów w jeden char* fun(char* buf, char* a, char* b)</a></li>
        <li><a href="ds4.html">ds4 - max index max_ind(int a, int b, int c, int d)</a></li>
		<li><a href="ds5.html">ds5 - (poprawkowy) dziwny max na longach max_1_ind(long long *tab, long long n, long long *even_count, long long *neg_count)</a></li>



      </ul>
    </nav>
</header>



<textarea style="width:2000px; height:10000px;" >
	

#----------------------------------------------------------------
# Program lab_2.s - Asemblery Laboratorium IS II rok
#----------------------------------------------------------------
#
#  To compile: as -o lab_2.o lab_2.s
#  To link:    ld -o lab_2 lab_2.o
#  To run:     ./lab_2
#
#----------------------------------------------------------------

	.equ	write_64, 1	#write data to file function
	.equ	exit_64, 60	#exit program function
	.equ	stdout, 0x01 	#handle to stdout

	.data
	
arg1txt:
	.ascii	"Arg1 = "
arg2txt:
	.ascii	"Arg2 = "
sumtxt:
	.ascii	"Sum  = "
difftxt:
	.ascii	"Diff = "
ortxt:
	.ascii	"OR   = "
andtxt:
	.ascii	"AND  = "
xortxt:
	.ascii	"XOR  = "
arg1:				#first argument
	.byte	0xA0
arg2:				#second argument
	.byte	0x05
result:				#result
	.byte	0
tmp:
	.byte	0
restxt:
	.ascii	"  \n"
txtlen:
	.quad	7
reslen:
	.quad	3
 
	.equ arg1len, arg2txt - arg1txt
	.equ arg2len, sumtxt - arg2txt

	.text
	.global _start
	
_start:
	NOP
	

	MOVB	arg1,%al
	MOV	$arg1txt,%rsi
	CALL	disp_line

	NOP

	MOVB	arg2,%al
	MOV	$arg2txt,%rsi
	CALL	disp_line

	NOP

	MOVB	arg1,%al
	ADDB	arg2,%al
	MOVB	%al,result
	MOV	$sumtxt,%rsi
	CALL	disp_line

	NOP

	MOVB	arg1,%al
	SUBB	arg2,%al
	MOVB	%al,result
	MOV	$difftxt,%rsi
	CALL	disp_line

	NOP

	MOVB	arg1,%al
	ORB	arg2,%al
	MOVB	%al,result
	MOV	$ortxt,%rsi
	CALL	disp_line

	NOP

	MOVB	arg1,%al
	ANDB	arg2,%al
	MOVB	%al,result
	MOV	$andtxt,%rsi
	CALL	disp_line

	NOP

	MOVB	arg1,%al
	XORB	arg2,%al
	MOVB	%al,result
	MOV	$xortxt,%rsi
	CALL	disp_line

	NOP

	MOV	$exit_64,%rax
	XOR	%rdi,%rdi 
	SYSCALL

#----------------------------------------------------------------
# disp_line - displays line of text (prompt + hexadecimal number)
#----------------------------------------------------------------

	.type disp_line,@function

disp_line:
	MOVB	%al, tmp

	MOV	$write_64,%rax
	MOV	$stdout,%rdi
	MOV	txtlen,%rdx
	SYSCALL

	MOVB	tmp,%al
	ANDB	$0x0F,%al
	CMPB	$10,%al
	JB	digit1
	ADDB	$('A'-0x0A),%al
	JMP	insert1
digit1:
	ADDB	$'0',%al
insert1:
	MOV	%al,%ah

	MOVB	tmp,%al
	SHR	$4,%al
	CMPB	$10,%al
	JB	digit2
	ADDB	$('A'-0x0A),%al
	JMP	insert2
digit2:
	ADDB	$'0',%al
insert2:
	MOVW	%ax, restxt

	MOV	$write_64,%rax
	MOV	$stdout,%rdi
	MOV	$restxt,%rsi
	MOV	reslen,%rdx
	SYSCALL

	RET
	
	
</textarea>