<header>
    <nav>
      <ul>
        <li><a href="lab1.html">lab1 - wyświetlanie </a></li>
        <li><a href="lab2.html">lab2 - wyświetlanie w 16-tkowym</a></li>
        <li><a href="lab3.html">lab3 - sortowanie tablicy int</a></li>
        <li><a href="lab4.html">lab4 - brak </a></li>
        <li><a href="lab5.html">lab5 - zamiana liter małych na duże i odwrotnie </a></li>

        <li><a href="lab6a.html">lab6a - silnia </a></li>
		<li><a href="lab6b.html">lab6b - fibonaci </a></li>

		<li><a href="lab7a.html">lab7a - silnia nie rekurencyjnie </a></li>
		<li><a href="lab7b.html">lab7b - fib nie rekurencyjnie </a></li>
		<li><a href="lab7d.html">lab7d - budowanie stringa </a></li>

        <li><a href="lab8a.html">lab8a - wyświetlanie zmiennych środowiskowych</a></li>


        <li><a href="lab9a.html">lab9a - operacje na zmiennoprzecinkowych </a></li>
        <li><a href="lab9b.html">lab9b - pierwiastki równania kwadratowego </a></li>

        <li><a href="jk1.html">jk1 - maksymalna różnica max_diff(ina, int b, int c, int d) </a></li>
        <li><a href="jk2.html">jk2 - generuj string generate_str(char* s, int c, int n, int inc) </a></li>
        <li><a href="jk3.html">jk3 - łączenie stringów w jeden char* fun(char* buf, char* a, char* b)</a></li>
        <li><a href="jk4.html">jk4 - max index max_ind(int a, int b, int c, int d)</a></li>
		<li><a href="jk5.html">jk5 - (poprawkowy) dziwny max na longach max_1_ind(long long *tab, long long n, long long *even_count, long long *neg_count)</a></li>




        <li><a href="pw1.html">pw1 - maksymalna różnica max_diff(ina, int b, int c, int d) </a></li>
        <li><a href="ds2.html">ds2 - generuj string generate_str(char* s, int c, int n, int inc) </a></li>
        <li><a href="ds3.html">ds3 - łączenie stringów w jeden char* fun(char* buf, char* a, char* b)</a></li>
        <li><a href="ds4.html">ds4 - max index max_ind(int a, int b, int c, int d)</a></li>
		<li><a href="ds5.html">ds5 - (poprawkowy) dziwny max na longach max_1_ind(long long *tab, long long n, long long *even_count, long long *neg_count)</a></li>



      </ul>
    </nav>
</header>

<textarea style="width:2000px; height:10000px;" >
# char* generate_str(char* s, int c, int n, int inc);

#nagłówki jak zawsze
	.text
	.type generate_str, @function
	.globl generate_str
	
generate_str:
	push %rdi #funkcja ma w zasadzie zwracać to samo, co podajemy jej jako pierwszy argument. ponieważ będziemy zwiększać ten wskaźnik który jest pierwszym argumentem, to najpierw wrzucamy sobie to na stos aby potem łatwo odzyskać jego pierwotną wartość
	
begin:
	mov %rsi,(%rdi) #kopiujemy drugi argument do MIEJSCA W PAMIĘCI wskazywanego przez rdi. nawiasy to takie jakby wyłuskanie zmiennej ze wskaźnika. np w C, jeśli mamy int* a, to napiszemy *a = 5
	inc %rdi #zwiększamy wskaźnik tak, aby wskazywał na kolejny element
	dec %rdx #zmniejszamy licznik
	cmp $0,%rcx #sprawdzamy czy mamy wyświetlać takie same znaki, czy zwiększać je o 1
	je next
	inc %rsi #zwiększamy o jeden znak z którego budujemy napis
	
next:
	cmp $0,%rdx #sprawdzamy czy licznik jest jeszcze większy od 0, jeśli tak to skaczemy z powrotem do begin
	jg begin
	movb $0,(%rdi) #kopiujemy na koniec jeszcze jeden bajt do naszego napisu, bajt ma wartość 0. to oczywiście nullterminator, bez którego nie będzie wiadomo gdzie się skończył nasz napis
	
	pop %rax #zwracamy wartość przez rax, chcemy zwrócić wskaźnik do naszego napisu. na początku wrzuciliśmy go na stos, więc teraz zdejmujemy
	ret





------------------------------___C_-------------------------



#include <stdlib.h>
#include <stdio.h>

#define BUFSIZE 100

char* generate_str(char* s, int c, int n, int inc);

int main(){
	char* buf = malloc(BUFSIZE*sizeof(char));
	
	printf("%s \n", generate_str(buf, 65, 15, 0));
	
	free(buf);

	return 0;
}





	</textarea>